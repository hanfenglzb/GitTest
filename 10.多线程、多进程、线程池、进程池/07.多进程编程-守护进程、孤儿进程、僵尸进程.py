# 守护进程
# Process对象的daemon属性设置为Ture，这个进程就会成为一个守护进程。
# 当一个进程退出时，会尝试终止它的子进程中所有的守护进程并释放资源之后再退出（但不包括非守护进程），
# 所以这导致Python的守护进程不允许再创建它的子进程，否则，当守护进程被自己的父进程终止的时候，对于它的子进程来说，
# 就相当于父进程被意外终止了，所有的子进程都将变成孤儿进程。在守护进程中创建子进程将抛出AssertionError(断言异常，
# 但是断言语句在启动Python解释器时如果指定了-O选项，其实是会被优化掉的，这一点要注意)
# *Python的守护进程是一个正常进程，并不是Unix/Linux系统下的守护进程或服务的概念。

# 另外，守护进程能被安全终止，是在它的父进程正常退出的情况下，如果父进程被突然终止，那么守护进程也会变成孤儿进程。
# 这一点跟线程是不一样的，守护线程就算所有主线程被突然终止了，在主进程退出后这些还在运行的线程也会被安全关闭。
# 但是守护进程就不一样了，因为进程之间是独立的，就算主进程被突然终止了，守护进程也还会继续运行。

# 孤儿进程
# 一个进程退出后，如果它还有子进程在运行，那么这些进程就会变成孤儿进程。
# 孤儿进程会被系统进程init收养(pid=1的进程，在Linux系统中为)，这时孤儿进程的父进程就变成了init进程。
# 当孤儿进程终止变成僵尸进程后，由系统进程负责通知操作系统回收资源。
# 孤儿进程一般是不会系统造成直接性的危害，但是也并不代表孤儿进程一定是安全的。
# 比如，当孤儿进程是一个socket服务时，主进程退出后，这个孤儿进程还占用着端口，甚至可能是死循环，一直无法退出。
# 因为端口一直被占用，会导致无法再次启动主进程。这时的孤儿进程会变成业务上的"僵尸进程"，占用着pid和一些资源。


# 僵尸进程（Linux系统的一种数据结构）
# 当子进程比父进程先运行完，操作系统会释放子进程占用的重型资源（比如内存空间、CPU资源、打开的文件等），
# 但会保留子进程的一些关键信息（比如PID、exitcode、运行时间等）。这种已经死掉的进程就进入僵尸状态，即僵尸进程。
# 僵尸进程的设计目的是为了让父进程能随时查看自己的子进程的信息，不管子进程是死的还是活的。
# 任何一个正常退出的子进程都会变成僵尸状态(主进程属于系统进程的子进程，变成僵尸状态后由系统进程进行资源的回收)，
# 但是被强制杀死的子进程不会变成僵尸状态，其资源会被操作系统回收。
# 对于僵尸进程，父进程应该及时清理，在确定不需要僵尸进程的信息之后，通知操作系统回收资源（wait / waitpid）
# 否则会导致僵尸进程占用的pid一直不释放，到后面可能都没有pid分配，进程无法启动。
# os.wait()/os.waitpid()

# 在multiprocessing中，父进程如果是正常退出，会终止守护进程并且清理僵尸进程，但是如果非守护的子进程还在运行，
# 它还是会变成孤儿进程。而且，进程还可能被意外终止！这会导致它所有的子进程不可避免的成为孤儿进程(守护进程也没时间终止)，
# 并且如果进程中有僵尸进程还未被清理，那么这些僵尸进程会变成孤儿僵尸进程，被系统进程收养。
# 所以在多进程编程中，应该保证一个进程及时清理它变成僵尸状态的子进程；并且被终止后还应该终止它所有还在运行的子进程，
# 防止其变成孤儿进程。


# 守护进程、孤儿进程、僵尸进程示例
import os

