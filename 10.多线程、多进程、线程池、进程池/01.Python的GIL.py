# 线程和进程的定义
# 线程：线程是程序执行的基本单位，一个进程至少有一个线程。
#   线程包含在进程中，本质上是进程中的单一顺序的控制流，是进程的实际执行单元
# 进程：进程是资源分配的基本单位，一个程序至少有一个进程。
#   进程可以申请和拥有系统资源，可以看成是一段程序的执行过程

# 线程和进程的联系：
#   一个进程可以创建多个线程，线程不持有资源，创建简单，开销小；
#   同一个进程中的线程共享进程中的所有资源，所以线程之间的通信简单，但会存在数据同步和互斥的问题。
#   一个程序可以创建多个进程，创建进程需要分配各种资源，创建进程的花销会比较大；
#   不同的进程之间拥有各自的资源，各自独立，所以进程之间的通信就会比较麻烦。

# 例子：公司要求举办一场活动，选定了一名或多名负责人，各个负责人在进行筹备的过程中，向公司申请资金和资源的支持，
# 然后又各自招募了一个或几个工作人员，把任务分配给工作人员，而工作人员根据任务要求，向对应的负责人申请需要的资金和资源完成任务。
# 公司：CPU
# 活动：程序
# 组织者：进程
# 工作人员：线程

# 一个进程可以有多个线程，但是一个CPU上同一时间只能运行一个线程，
# 对于多核CPU，进程可以将线程分配到其他的CPU上运行，这样多个线程就可以并行运行（C，C++，Java的多线程）。
# 但是CPU是有限的，如果多个进程都要运行，那么就算可以将线程分配到其他CPU上，一旦同一时间需要运行的线程数量超过CPU的数量，
# 势必会造成不同线程之间的竞争，这个时候就涉及到了线程的调度。
# 常见的调度算法：
#   FIFO：先添加的先运行，运行完毕后再下一个；假如有一个线程需要处理紧急事件，那么也只能等待。
#   时间片轮转：一个线程运行一定的时间，不管有没有运行完毕，都切换下一个；一个线程马上运行完毕，被强制切换，只能等待下一次调度。
#   优先级调度：线程之间有优先级，优先级高的先执行；但是假如一直有高优先级的线程，低优先级的线程永远也不能执行。


# GIL: Global Interpreter Lock 全局解释器锁
# GIL是CPython解释器在多线程环境下采用的一种机制，为了解决对象模型在并发访问下的数据安全问题做的一种简便实现。
# CPython的线程调用的是C语言的原生线程，不能直接操作CPU，只能利用GIL去保证同一时间只有一个线程能拿到数据。
#
# 在整个CPython解释器进程上加上一把GIL，只有获得了GIL的线程才能进入CPU运行（GIL相当于线程可以进入CPU运行的通行证），
# 而一个解释器进程中只有一把GIL，所以这样就保证了在同一时间只能有一个线程能获得这把锁然后去运行。
# 但也正是因为一个解释器进程只有一把GIL，那么在同一时间内，除了获得了GIL的线程外，其他线程都不能运行，
# 就算计算机有多核CPU，解释器进程也不能将其他线程分配到空闲的CPU上，因为其他线程没有获得GIL。
# 所以这就导致Python程序在只有一个进程的情况下，同一时间只能利用一个CPU执行一个线程。
# (上述的一个CPU并不一定是同一个CPU，具体看操作系统的调度)

# GIL释放时机：
# 1.当前运行的线程被阻塞，只有解除阻塞后，才能参与调度；如线程遇到IO操作、线程中调用sleep()、线程的子线程调用join()等
# 2.
#   Python2：ticks计数达到100时释放GIL
#       ticks是Python的一个专门用于GIL的计数器，每次释放GIL后归零，可通过sys.setcheckinterval设置
#   Python3：改用计时器，运行时间达到阈值后（15ms）释放GIL
# 特殊情况：
#   一些计算密集的标准库或第三方库会去除GIL限制

# Python线程的五个状态：
# 初始状态：线程对象刚被创建时的状态
# 就绪状态：就绪状态的线程可以被解释器进程调度运行。但是如果没有被进程调度，那么它一直都是就绪状态。
#   初始状态的线程调用start()、线程解除了阻塞状态等情况就进入就绪状态
# 运行状态：线程处于运行run()时的状态。
#   碰到I/O操作、当前线程主动sleep()、父线程被子线程join()等，线程就会进入阻塞状态
#   如果没有碰到阻塞的情况下运行完相应的时间片或字节码行数后，线程run()运行完成，则进入死亡状态；没有运行完成，则进入就绪状态，等待下一次的调度运行
# 阻塞状态：处于阻塞状态的线程不会再被调度，直到线程解除阻塞进入就绪状态。
# 死亡状态：线程run()方法完成，或者是一个守护线程的情况下，程序没有存活的非守护线程，被强行终止，则线程死亡。线程一旦死亡，就不能再复生

# CPython的解释器在运行多线程时的操作：
# 1.线程被解释器进程调度，加上GIL
# 2.切换进线程
# 3.线程执行下列操作之一：
#   a.运行ticks计数器设置字节码条数或指定时间片后
#   b.线程被阻塞（例如遇到I/O操作，或者其他情况的阻塞）
# 4.切换出线程
# 5.解释器进程释放GIL
# 6.开始新一次的线程调度
# 注意：线程被切换出去，解释器进程释放GIL后，如果这个线程不是处于阻塞状态，那么它仍然会参与到和其他线程竞争进程的调度中。
# 也就是说，有一个线程刚执行完，只要它是就绪状态，但下一次被解释器进程调度运行的线程还是有可能是它，
# Python3针对线程的调度做了优化，但也不能完全避免这种情况，因为Python的线程是没有优先级的概念的


# GIL的存在并不代表着CPython的多线程一定是数据安全的，因为在线程的运行过程中GIL是会被释放的，释放时机如上。
# 假设有一个线程A正好要修改一个数据时，GIL被释放了，切换执行另一个线程B，而线程B也对这个数据做修改，
# 再次切换回线程A时，A线程根据被切换时保存的上下文现场，继续被打断的数据修改操作，但这个时候数据已经被修改过了，
# 线程A再根据之前的内容对该数据做修改，最终造成该数据修改的错误。
# >>>CPython很多操作是原子性的!<<<
# 如何查看一个操作是否为原子性？
# 使用dis.dis()查看该操作的字节码，如果这个操作只有一条字节码，则该操作是原子性的
# 如果一个操作有多条字节码，则是非原子性的，就有可能造成线程不安全
# 因为线程有可能在运行完前几条字节码，就被切换了，等再次切换回该线程时，接着之前保存的上下文运行，使用保存的数据做修改
# 但这个时候另一个线程已经把原先的数据给修改了，
# https://docs.python.org/zh-cn/3.10/faq/library.html#id18
# 例：
import threading

data = 0


def add():
    global data
    for i in range(1000000):
        data = data + 1


def sub():
    global data
    for i in range(1000000):
        data = data - 1


thread_add = threading.Thread(target=add)
thread_sub = threading.Thread(target=sub)
thread_add.start()
thread_sub.start()
thread_add.join()
thread_sub.join()
print(data)
