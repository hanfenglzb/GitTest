# 选择排序
# 遍历序列，每次找出还未排序的最小的一个数据，放到序列的前面（已经排好序的数据的后一个位置）
# 每次遍历怎么找最小的数据？
# 每次遍历时把要排的那个数据视为最小的，然后逐个和后面的比较，如果后面有比它小的，
# 则把更小那个当成最小的，直到找出所有还没有排序的数据中最小那个，和要排的那个位置的数据交换。

def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):  # 排到倒数第二个时，最后那个就不用再排了，肯定是最大的，所以n-1次选择就行
        min_value_index = i  # 每次遍历把要排的那个数据当成最小值，记录下索引位置
        for j in range(i + 1, n):
            # 从要排的后一个值开始遍历整个序列，每一个值都跟最小值比较，如果比最小值更小，
            # 则把这个值当成最小值，更改最小值的索引，直到比较完所有的数据
            if arr[j] < arr[min_value_index]:
                min_value_index = j
        # 比较完一轮的所有数据后，如果最小值的索引发生改变，说明最小值不是第一个指定的数据，把最小值交换到要排的那个位置
        if min_value_index != i:
            arr[i], arr[min_value_index] = arr[min_value_index], arr[i]
    return arr


# 时间复杂度：不管什么数据，就算已经排好序的数据给它，它每一次想要固定下一个数据，都要和后面的每一个进行比较，选择出最小的
#   最好情况：O(n^2)
#   最坏情况：O(n^2)
#   平均：O(n^2)
# 空间复杂度：O(1)，只使用有限的几个变量
# 排序方式：原地排序（in-place），还是在原来的序列中进行数据的交换
# 稳定性：不稳定，比如：6 7 6 2 8，第一次会把第一个6换到2的位置上

# 选择排序是冒泡排序的一个变种，每一次不交换数据，只记录最小索引，最后进行交换，减少数据交换操作
